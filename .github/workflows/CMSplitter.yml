import fs from "fs/promises";
import path from "path";

const ROOT = process.cwd();
const PRODUCTS_DIR = path.join(ROOT, "CM-Data", "Products");
const PRICEHISTORY_DIR = path.join(ROOT, "CM-Data", "PriceHistory");
const FINAL_DIR = path.join(ROOT, "CM-Data", "Final", "PriceHistory");

import { parseArgs } from "node:util";

// definiere erlaubte Optionen
const { values } = parseArgs({
  options: {
    date:   { type: "string" },
    market: { type: "string" },
  },
  allowPositionals: true,
});

// sanitize: normalize leere/„null“/„undefined“
const sanitize = (v) => {
  if (v == null) return "";
  let s = String(v).trim();
  if (s === "null" || s === "undefined" || s === '""' || s === "''") s = "";
  return s;
};

const INPUT_DATE   = sanitize(values.date);
const INPUT_MARKET = sanitize(values.market);


async function fileExists(p) {
  try { await fs.access(p); return true; } catch { return false; }
}

async function readJSON(p) {
  return JSON.parse(await fs.readFile(p, "utf8"));
}

async function readArrayOrKey(p, key) {
  const j = await readJSON(p);
  if (Array.isArray(j)) return j;
  if (key && Array.isArray(j[key])) return j[key];
  throw new Error(`Inhalt in ${p} hat weder ein Array-Root noch das Array-Feld "${key}".`);
}

async function listMarketsFromProducts() {
  const files = await fs.readdir(PRODUCTS_DIR);
  const mks = new Set();
  for (const f of files) {
    const m = f.match(/products_(?:non)?singles_(\d+)\.json$/);
    if (m) mks.add(m[1]);
  }
  return [...mks].sort();
}

async function findLatestPriceGuideForMarket(market, preferDate /* YYYY-MM-DD or "" */) {
  // Sammle Month-Ordner (YYYY-MM), neueste zuerst
  const entries = await fs.readdir(PRICEHISTORY_DIR, { withFileTypes: true });
  const monthDirs = entries
    .filter(e => e.isDirectory())
    .map(e => e.name)
    .filter(n => /^\d{4}-\d{2}$/.test(n))
    .sort().reverse();

  // Wenn explizites Datum vorgegeben ist → direkte Datei
  if (preferDate) {
    const month = preferDate.slice(0, 7);
    const p = path.join(PRICEHISTORY_DIR, month, `price_guide_${market}_${preferDate}.json`);
    if (await fileExists(p)) return { date: preferDate, filepath: p, month };
    throw new Error(`Price guide für Markt ${market} am ${preferDate} nicht gefunden.`);
  }

  // sonst: neueste Datei finden
  const rx = new RegExp(`^price_guide_${market}_(\\d{4}-\\d{2}-\\d{2})\\.json$`);
  let bestDate = null;
  let bestPath = null;

  for (const mdir of monthDirs) {
    const dir = path.join(PRICEHISTORY_DIR, mdir);
    const files = await fs.readdir(dir);
    for (const f of files) {
      const mm = f.match(rx);
      if (mm) {
        const d = mm[1];
        if (!bestDate || d > bestDate) {
          bestDate = d;
          bestPath = path.join(dir, f);
        }
      }
    }
    if (bestDate) break;
  }
  if (!bestDate) throw new Error(`Kein price_guide_* für Markt ${market} gefunden.`);
  return { date: bestDate, filepath: bestPath, month: bestDate.slice(0,7) };
}

async function loadProductMaps(market) {
  const singlesPath = path.join(PRODUCTS_DIR, `products_singles_${market}.json`);
  const nonsinglesPath = path.join(PRODUCTS_DIR, `products_nonsingles_${market}.json`);

  if (!(await fileExists(singlesPath))) {
    throw new Error(`Fehlt: ${singlesPath}`);
  }
  if (!(await fileExists(nonsinglesPath))) {
    throw new Error(`Fehlt: ${nonsinglesPath}`);
  }

  // WICHTIG: Dateien haben Schema {version, createdAt, products:[...]}
  const singles = await readArrayOrKey(singlesPath, "products");
  const nonsingles = await readArrayOrKey(nonsinglesPath, "products");

  console.log(`ℹ️ Products m${market}: singles=${singles.length}, nonsingles=${nonsingles.length}`);

  const byId = new Map();
  for (const p of [...singles, ...nonsingles]) {
    // Erwartete Felder: idProduct, idExpansion, name, categoryName, idCategory
    if (!p || p.idProduct == null) continue;
    byId.set(p.idProduct, {
      idExpansion: p.idExpansion ?? null,
      productName: p.name ?? null,
      categoryName: p.categoryName ?? null,
      idCategoryProduct: p.idCategory ?? null,
    });
  }
  return byId;
}

function groupByExpansion(priceGuides, productMap) {
  const groups = new Map(); // expId -> items[]
  const unknown = [];

  for (const row of priceGuides) {
    if (!row || row.idProduct == null) continue;
    const meta = productMap.get(row.idProduct);
    const exp = meta?.idExpansion ?? null;
    const enriched = {
      ...row,
      productName: meta?.productName ?? null,
      productCategoryName: meta?.categoryName ?? null
    };
    if (exp == null) {
      unknown.push(enriched);
      continue;
    }
    if (!groups.has(exp)) groups.set(exp, []);
    groups.get(exp).push(enriched);
  }
  return { groups, unknown };
}

async function ensureDir(p) {
  await fs.mkdir(p, { recursive: true });
}

async function writeOutput(date, market, groups, unknown) {
  // Ziel: CM-Data/Final/PriceHistory/YYYY-MM-DD/{m<market>_expansion_<id>.json}
  const outDir = path.join(FINAL_DIR, date);
  await ensureDir(outDir);

  const index = [];
  // stabile Sortierung nach expId
  const entries = [...groups.entries()].sort((a, b) => Number(a[0]) - Number(b[0]));

  for (const [expId, items] of entries) {
    const out = {
      date,
      market: Number(market),
      expansionId: Number(expId),
      count: items.length,
      priceGuides: items
    };
    const file = path.join(outDir, `m${market}_expansion_${expId}.json`);
    await fs.writeFile(file, JSON.stringify(out, null, 2), "utf8");
    index.push({ expansionId: Number(expId), count: items.length, file: path.basename(file) });
  }

  if (unknown.length) {
    const ufile = path.join(outDir, `m${market}_expansion_unknown.json`);
    await fs.writeFile(ufile, JSON.stringify({
      date, market: Number(market), expansionId: null, count: unknown.length, priceGuides: unknown
    }, null, 2), "utf8");
    index.push({ expansionId: null, count: unknown.length, file: path.basename(ufile) });
  }

  await fs.writeFile(path.join(outDir, "index.json"), JSON.stringify({
    date, market: Number(market), files: index
  }, null, 2), "utf8");

  // kleine Spur für Commit-Message
  await fs.writeFile(path.join(outDir, "_metadata.txt"), `date=${date}\nmarket=${market}\n`, "utf8");
}

async function main() {
  const markets = INPUT_MARKET ? [INPUT_MARKET] : await listMarketsFromProducts();
  if (markets.length === 0) {
    throw new Error("Keine Märkte unter CM-Data/Products gefunden.");
  }

  for (const market of markets) {
    const { date, filepath } = await findLatestPriceGuideForMarket(market, INPUT_DATE);

    // PriceGuide hat Schema {version, createdAt, priceGuides:[...]}
    const pg = await readJSON(filepath);
    const priceGuides = Array.isArray(pg) ? pg
      : Array.isArray(pg?.priceGuides) ? pg.priceGuides
      : (() => { throw new Error(`Inhalt in ${filepath} enthält kein Array "priceGuides".`); })();

    console.log(`ℹ️ PriceGuide m${market} @ ${date}: rows=${priceGuides.length}`);

    const productMap = await loadProductMaps(market);
    const { groups, unknown } = groupByExpansion(priceGuides, productMap);
    await writeOutput(date, market, groups, unknown);

    console.log(`✔️ Markt ${market}: ${groups.size} Expansionen + ${unknown.length} unbekannte Einträge → CM-Data/Final/PriceHistory/${date}`);
  }
}

main().catch(err => {
  console.error("❌ Split-Job fehlgeschlagen:", err);
  process.exit(1);
});
