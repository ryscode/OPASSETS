name: Split price guide by expansion

on:
  schedule:
    - cron: '15 3 * * *'  # täglich 03:15 UTC
  workflow_dispatch:
    inputs:
      date:
        description: 'Optional: Datum (YYYY-MM-DD) statt "neuester Dump"'
        required: false
        type: string
      market:
        description: 'Optional: nur diesen Markt splitten (z.B. 18)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: split-priceguide-by-expansion
  cancel-in-progress: true

jobs:
  split:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # legt die JS-Datei im Repo ab
      - name: Add splitter script
        shell: bash
        run: |
          mkdir -p scripts
          cat > scripts/split_priceguide_by_expansion.mjs <<'EOF'
          import fs from "fs/promises";
          import path from "path";
          import { parseArgs } from "node:util";

          const ROOT = process.cwd();
          const PRODUCTS_DIR = path.join(ROOT, "CM-Data", "Products");
          const PRICEHISTORY_DIR = path.join(ROOT, "CM-Data", "PriceHistory");
          const FINAL_DIR = path.join(ROOT, "CM-Data", "Final", "PriceHistory");

          const { values } = parseArgs({
            options: {
              date:   { type: "string" },
              market: { type: "string" },
            },
            allowPositionals: true,
          });

          const sanitize = (v) => {
            if (v == null) return "";
            let s = String(v).trim();
            if (s === "null" || s === "undefined" || s === '""' || s === "''") s = "";
            return s;
          };
          const INPUT_DATE   = sanitize(values.date);
          const INPUT_MARKET = sanitize(values.market);

          async function fileExists(p) { try { await fs.access(p); return true; } catch { return false; } }
          async function readJSON(p) { return JSON.parse(await fs.readFile(p, "utf8")); }
          async function readArrayOrKey(p, key) {
            const j = await readJSON(p);
            if (Array.isArray(j)) return j;
            if (key && Array.isArray(j[key])) return j[key];
            throw new Error(`Inhalt in ${p} hat weder ein Array-Root noch das Array-Feld "${key}".`);
          }

          async function listMarketsFromProducts() {
            const files = await fs.readdir(PRODUCTS_DIR);
            const mks = new Set();
            for (const f of files) {
              const m = f.match(/products_(?:non)?singles_(\d+)\.json$/);
              if (m) mks.add(m[1]);
            }
            return [...mks].sort();
          }

          async function findLatestPriceGuideForMarket(market, preferDate) {
            const entries = await fs.readdir(PRICEHISTORY_DIR, { withFileTypes: true });
            const monthDirs = entries
              .filter(e => e.isDirectory()).map(e => e.name)
              .filter(n => /^\d{4}-\d{2}$/.test(n)).sort().reverse();

            if (preferDate) {
              const month = preferDate.slice(0, 7);
              const p = path.join(PRICEHISTORY_DIR, month, `price_guide_${market}_${preferDate}.json`);
              if (await fileExists(p)) return { date: preferDate, filepath: p, month };
              throw new Error(`Price guide für Markt ${market} am ${preferDate} nicht gefunden.`);
            }

            const rx = new RegExp(`^price_guide_${market}_(\\d{4}-\\d{2}-\\d{2})\\.json$`);
            let bestDate = null, bestPath = null;
            for (const mdir of monthDirs) {
              const dir = path.join(PRICEHISTORY_DIR, mdir);
              const files = await fs.readdir(dir);
              for (const f of files) {
                const mm = f.match(rx);
                if (mm && (!bestDate || mm[1] > bestDate)) {
                  bestDate = mm[1];
                  bestPath = path.join(dir, f);
                }
              }
              if (bestDate) break;
            }
            if (!bestDate) throw new Error(`Kein price_guide_* für Markt ${market} gefunden.`);
            return { date: bestDate, filepath: bestPath, month: bestDate.slice(0,7) };
          }

          async function loadProductMaps(market) {
            const singlesPath = path.join(PRODUCTS_DIR, `products_singles_${market}.json`);
            const nonsinglesPath = path.join(PRODUCTS_DIR, `products_nonsingles_${market}.json`);
            if (!(await fileExists(singlesPath))) throw new Error(`Fehlt: ${singlesPath}`);
            if (!(await fileExists(nonsinglesPath))) throw new Error(`Fehlt: ${nonsinglesPath}`);

            const singles = await readArrayOrKey(singlesPath, "products");
            const nonsingles = await readArrayOrKey(nonsinglesPath, "products");
            console.log(`ℹ️ Products m${market}: singles=${singles.length}, nonsingles=${nonsingles.length}`);

            const byId = new Map();
            for (const p of [...singles, ...nonsingles]) {
              if (!p || p.idProduct == null) continue;
              byId.set(p.idProduct, {
                idExpansion: p.idExpansion ?? null,
                productName: p.name ?? null,
                categoryName: p.categoryName ?? null,
                idCategoryProduct: p.idCategory ?? null,
              });
            }
            return byId;
          }

          function groupByExpansion(priceGuides, productMap) {
            const groups = new Map();
            const unknown = [];
            for (const row of priceGuides) {
              if (!row || row.idProduct == null) continue;
              const meta = productMap.get(row.idProduct);
              const exp = meta?.idExpansion ?? null;
              const enriched = {
                ...row,
                productName: meta?.productName ?? null,
                productCategoryName: meta?.categoryName ?? null
              };
              if (exp == null) unknown.push(enriched);
              else {
                if (!groups.has(exp)) groups.set(exp, []);
                groups.get(exp).push(enriched);
              }
            }
            return { groups, unknown };
          }

          async function ensureDir(p) { await fs.mkdir(p, { recursive: true }); }
          async function writeOutput(date, market, groups, unknown) {
            const outDir = path.join(FINAL_DIR, date); // Ordner: YYYY-MM-DD
            await ensureDir(outDir);

            const index = [];
            for (const [expId, items] of [...groups.entries()].sort((a,b)=>Number(a[0])-Number(b[0]))) {
              const out = { date, market: Number(market), expansionId: Number(expId), count: items.length, priceGuides: items };
              const file = path.join(outDir, `m${market}_expansion_${expId}.json`);
              await fs.writeFile(file, JSON.stringify(out, null, 2), "utf8");
              index.push({ expansionId: Number(expId), count: items.length, file: path.basename(file) });
            }
            if (unknown.length) {
              const ufile = path.join(outDir, `m${market}_expansion_unknown.json`);
              await fs.writeFile(ufile, JSON.stringify({ date, market: Number(market), expansionId: null, count: unknown.length, priceGuides: unknown }, null, 2), "utf8");
              index.push({ expansionId: null, count: unknown.length, file: path.basename(ufile) });
            }
            await fs.writeFile(path.join(outDir, "index.json"), JSON.stringify({ date, market: Number(market), files: index }, null, 2), "utf8");
            await fs.writeFile(path.join(outDir, "_metadata.txt"), `date=${date}\nmarket=${market}\n`, "utf8");
          }

          async function main() {
            const markets = INPUT_MARKET ? [INPUT_MARKET] : await listMarketsFromProducts();
            if (markets.length === 0) throw new Error("Keine Märkte unter CM-Data/Products gefunden.");

            for (const market of markets) {
              const { date, filepath } = await findLatestPriceGuideForMarket(market, INPUT_DATE);
              const pg = await readJSON(filepath); // {version, createdAt, priceGuides:[...]}
              const priceGuides = Array.isArray(pg) ? pg
                : Array.isArray(pg?.priceGuides) ? pg.priceGuides
                : (() => { throw new Error(`Inhalt in ${filepath} enthält kein Array "priceGuides".`); })();

              console.log(`ℹ️ PriceGuide m${market} @ ${date}: rows=${priceGuides.length}`);
              const productMap = await loadProductMaps(market);
              const { groups, unknown } = groupByExpansion(priceGuides, productMap);
              await writeOutput(date, market, groups, unknown);
              console.log(`✔️ Markt ${market}: ${groups.size} Expansionen + ${unknown.length} unbekannte → CM-Data/Final/PriceHistory/${date}`);
            }
          }

          main().catch(err => { console.error("❌ Split-Job fehlgeschlagen:", err); process.exit(1); });
          EOF

      - name: Run splitter
        shell: bash
        run: |
          ARGS=()
          if [[ -n "${{ inputs.date }}" ]]; then ARGS+=(--date "${{ inputs.date }}"); fi
          if [[ -n "${{ inputs.market }}" ]]; then ARGS+=(--market "${{ inputs.market }}"); fi
          node scripts/split_priceguide_by_expansion.mjs "${ARGS[@]}"

      - name: Commit & push
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: split price guide by expansion (auto)"
          file_pattern: |
            CM-Data/Final/PriceHistory/**/*
            scripts/split_priceguide_by_expansion.mjs
