name: Split price guide by expansion

on:
  schedule:
    - cron: '15 3 * * *'  # täglich 03:15 UTC
  workflow_dispatch:
    inputs:
      date:
        description: 'Optional: Datum (YYYY-MM-DD) statt "neuester Dump"'
        required: false
        type: string
      market:
        description: 'Optional: nur diesen Markt splitten (z.B. 18)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: split-priceguide-by-expansion
  cancel-in-progress: true

jobs:
  split:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Add splitter script
        shell: bash
        run: |
          mkdir -p scripts
          cat > scripts/split_priceguide_by_expansion.mjs <<'EOF'
          import fs from "fs/promises";
          import path from "path";
          import { parseArgs } from "node:util";

          const ROOT = process.cwd();
          const PRODUCTS_DIR = path.join(ROOT, "CM-Data", "Products");
          const PRICEHISTORY_DIR = path.join(ROOT, "CM-Data", "PriceHistory");
          const FINAL_DIR = path.join(ROOT, "CM-Data", "Final", "PriceHistory");

          // ===== CLI args (robust) =====
          const { values } = parseArgs({
            options: {
              date:   { type: "string" },
              market: { type: "string" },
            },
            allowPositionals: true,
          });
          const sanitize = (v) => {
            if (v == null) return "";
            let s = String(v).trim();
            if (s === "null" || s === "undefined" || s === '""' || s === "''") s = "";
            return s;
          };
          const INPUT_DATE   = sanitize(values.date);
          const INPUT_MARKET = sanitize(values.market);

          // ===== FS helpers =====
          async function fileExists(p) { try { await fs.access(p); return true; } catch { return false; } }
          async function readJSON(p) { return JSON.parse(await fs.readFile(p, "utf8")); }
          async function readArrayOrKey(p, key) {
            const j = await readJSON(p);
            if (Array.isArray(j)) return j;
            if (key && Array.isArray(j[key])) return j[key];
            throw new Error(`Inhalt in ${p} hat weder ein Array-Root noch das Array-Feld "${key}".`);
          }
          async function ensureDir(p) { await fs.mkdir(p, { recursive: true }); }

          // ===== Markets discover =====
          async function listMarketsFromProducts() {
            const files = await fs.readdir(PRODUCTS_DIR);
            const mks = new Set();
            for (const f of files) {
              const m = f.match(/products_(?:non)?singles_(\d+)\.json$/);
              if (m) mks.add(m[1]);
            }
            return [...mks].sort();
          }

          // ===== Price guide picker =====
          async function findLatestPriceGuideForMarket(market, preferDate) {
            const entries = await fs.readdir(PRICEHISTORY_DIR, { withFileTypes: true });
            const monthDirs = entries
              .filter(e => e.isDirectory()).map(e => e.name)
              .filter(n => /^\d{4}-\d{2}$/.test(n)).sort().reverse();

            if (preferDate) {
              const month = preferDate.slice(0, 7);
              const p = path.join(PRICEHISTORY_DIR, month, `price_guide_${market}_${preferDate}.json`);
              if (await fileExists(p)) return { date: preferDate, filepath: p, month };
              throw new Error(`Price guide für Markt ${market} am ${preferDate} nicht gefunden.`);
            }

            const rx = new RegExp(`^price_guide_${market}_(\\d{4}-\\d{2}-\\d{2})\\.json$`);
            let bestDate = null, bestPath = null;
            for (const mdir of monthDirs) {
              const dir = path.join(PRICEHISTORY_DIR, mdir);
              const files = await fs.readdir(dir);
              for (const f of files) {
                const mm = f.match(rx);
                if (mm && (!bestDate || mm[1] > bestDate)) {
                  bestDate = mm[1];
                  bestPath = path.join(dir, f);
                }
              }
              if (bestDate) break;
            }
            if (!bestDate) throw new Error(`Kein price_guide_* für Markt ${market} gefunden.`);
            return { date: bestDate, filepath: bestPath, month: bestDate.slice(0,7) };
          }

          // ===== Product maps =====
          async function loadProductMaps(market) {
            const singlesPath = path.join(PRODUCTS_DIR, `products_singles_${market}.json`);
            const nonsinglesPath = path.join(PRODUCTS_DIR, `products_nonsingles_${market}.json`);
            if (!(await fileExists(singlesPath))) throw new Error(`Fehlt: ${singlesPath}`);
            if (!(await fileExists(nonsinglesPath))) throw new Error(`Fehlt: ${nonsinglesPath}`);

            const singles = await readArrayOrKey(singlesPath, "products");
            const nonsingles = await readArrayOrKey(nonsinglesPath, "products");
            console.log(`ℹ️ Products m${market}: singles=${singles.length}, nonsingles=${nonsingles.length}`);

            const byId = new Map();
            for (const p of [...singles, ...nonsingles]) {
              if (!p || p.idProduct == null) continue;
              byId.set(p.idProduct, {
                idExpansion: p.idExpansion ?? null,
                productName: p.name ?? null,
                categoryName: p.categoryName ?? null,
                idCategoryProduct: p.idCategory ?? null,
              });
            }
            return byId;
          }

          // ===== Expansion name resolver =====
          function deriveNameFromNonSingles(names = []) {
            for (const s of names) {
              const m = s.match(/Set\s*-\s*([^()]+?)\s*\(/);
              if (m) return m[1].trim();
            }
            for (const s of names) {
              const m = s.match(/Starter Deck:\s*(.+)/);
              if (m) return m[1].trim();
            }
            for (const s of names) {
              for (const kw of [
                " Sleeved Booster",
                " Box Promotion Booster",
                " Booster
