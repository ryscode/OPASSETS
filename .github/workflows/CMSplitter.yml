name: Split price guide by expansion

on:
  schedule:
    - cron: "15 3 * * *"   # täglich 03:15 UTC
  workflow_dispatch:
    inputs:
      date:
        description: "Optional: Datum (YYYY-MM-DD) statt 'neuester Dump'"
        required: false
        type: string
      market:
        description: "Optional: nur diesen Markt splitten (z. B. 18)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: split-priceguide-by-expansion
  cancel-in-progress: true

jobs:
  split:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Add splitter script
        shell: bash
        run: |
          mkdir -p scripts
          cat > scripts/split-priceguide-by-expansion.mjs <<'EOF'
          import fs from 'node:fs/promises';
          import path from 'node:path';

          const ROOT = process.cwd();
          const PRICEHIST_DIR = path.join(ROOT, 'CM-Data', 'PriceHistory');
          const PRODUCTS_DIR   = path.join(ROOT, 'CM-Data', 'Products');
          const FINAL_DIR      = path.join(ROOT, 'CM-Data', 'Final', 'PriceHistory');

          const FORCE_DATE    = (process.env.FORCE_DATE || '').trim();
          const MARKET_FILTER = (process.env.MARKET_FILTER || '').trim();

          const ensureNL = s => (s.endsWith('\n') ? s : s + '\n');
          function stableStringify(obj) {
            const sortObj = (o) => {
              if (Array.isArray(o)) return o.map(sortObj);
              if (o && typeof o === 'object') {
                const out = {};
                for (const k of Object.keys(o).sort()) out[k] = sortObj(o[k]);
                return out;
              }
              return o;
            };
            return ensureNL(JSON.stringify(sortObj(obj), null, 2));
          }
          async function listFiles(dir, rx) {
            const out = [];
            async function rec(d) {
              const entries = await fs.readdir(d, { withFileTypes: true });
              for (const e of entries) {
                const p = path.join(d, e.name);
                if (e.isDirectory()) await rec(p);
                else if (rx.test(p)) out.push(p);
              }
            }
            await rec(dir);
            return out;
          }
          function parseDateFromPriceGuideName(file) {
            const bn = path.basename(file);
            const m = bn.match(/^price_guide_(\d+)_([0-9]{4}-[0-9]{2}-[0-9]{2})\.json$/);
            return m ? { langOrMarket: m[1], date: m[2] } : null;
          }
          function parseDateFromProductsName(file) {
            const bn = path.basename(file);
            const m = bn.match(/^products_(single|singles|nonsingle|nonsingles)(?:_(\d+))?_([0-9]{4}-[0-9]{2}-[0-9]{2})\.json$/i);
            return m ? { market: m[2] || null, date: m[3] } : null;
          }
          function normalizeCode(raw) {
            if (!raw) return null;
            const m = String(raw).replace(/[\[\]()]/g, '').match(/^([A-Z]{2})-?(\d{2})$/);
            return m ? `${m[1]}-${m[2]}` : null;
          }
          function guessCodeFromName(name) {
            if (!name || typeof name !== 'string') return null;
            const pats = [
              /\(([A-Z]{2}-?\d{2})-\d{3}\)/, /\[([A-Z]{2}-?\d{2})\]/,
              /(?:^|\s)([A-Z]{2}-?\d{2})-\d{3}\b/, /(?:^|\s)\(([A-Z]{2}-?\d{2})\)(?:\s|$)/
            ];
            for (const rx of pats) { const m = name.match(rx); if (m) return normalizeCode(m[1]); }
            return null;
          }
          async function readJson(file) { return JSON.parse(await fs.readFile(file, 'utf8')); }

          async function main() {
            const pgFiles = await listFiles(PRICEHIST_DIR, /price_guide_\d+_\d{4}-\d{2}-\d{2}\.json$/);
            if (!pgFiles.length) { console.log('ℹ️ Keine price_guide_*.json gefunden.'); return; }
            const byDate = {};
            for (const f of pgFiles) {
              const m = parseDateFromPriceGuideName(f); if (!m) continue;
              (byDate[m.date] ||= []).push({ file: f, ...m });
            }
            let targetDate = FORCE_DATE || Object.keys(byDate).sort().pop();
            if (!byDate[targetDate]) throw new Error(`Kein price_guide_* für Datum ${targetDate} gefunden.`);
            let todaysGuides = byDate[targetDate];
            if (MARKET_FILTER) todaysGuides = todaysGuides.filter(g => g.langOrMarket === MARKET_FILTER);
            if (!todaysGuides.length) { console.log(`ℹ️ Keine price_guide_* für Markt ${MARKET_FILTER}.`); return; }
            console.log(`📅 Dump-Datum: ${targetDate} | Dateien: ${todaysGuides.length} | Markt-Filter: ${MARKET_FILTER || '—'}`);

            const prodFiles = await listFiles(PRODUCTS_DIR, /products_(?:single|singles|nonsingle|nonsingles)(?:_\d+)?_\d{4}-\d{2}-\d{2}\.json$/i);
            let latestSingles = null, latestSinglesDate = null;
            for (const f of prodFiles) {
              const meta = parseDateFromProductsName(f); if (!meta) continue;
              if (/singles?/i.test(f)) if (!latestSinglesDate || meta.date > latestSinglesDate) { latestSingles = f; latestSinglesDate = meta.date; }
            }
            if (!latestSingles) {
              const f = (await listFiles(PRODUCTS_DIR, /products_singles(?:_\d+)?\.json$/i)).sort().pop();
              if (f) latestSingles = f;
            }
            if (!latestSingles) { console.log('❌ Keine Products Singles gefunden.'); process.exit(1); }
            console.log('🧾 Products Singles:', path.relative(ROOT, latestSingles));

            const singlesJson = await readJson(latestSingles);
            const singlesArr = Array.isArray(singlesJson?.products) ? singlesJson.products
                              : Array.isArray(singlesJson) && singlesJson[0]?.products ? singlesJson[0].products
                              : [];
            const productById = new Map();
            const codeHintsByExpansion = new Map();
            for (const p of singlesArr) {
              if (!p || p.idProduct == null) continue;
              if (!productById.has(p.idProduct)) productById.set(p.idProduct, p);
              if (p.idExpansion != null && p.name) {
                const code = guessCodeFromName(p.name);
                if (code) (codeHintsByExpansion.get(p.idExpansion) || codeHintsByExpansion.set(p.idExpansion, []).get(p.idExpansion)).push(code);
              }
            }
            const codeGuessForExpansion = new Map(
              [...codeHintsByExpansion.entries()].map(([exp, list]) => {
                const freq = list.reduce((a,c)=>(a[c]=(a[c]||0)+1,a),{});
                return [exp, Object.entries(freq).sort((a,b)=>b[1]-a[1])[0][0]];
              })
            );

            const outDir = path.join(FINAL_DIR, targetDate);
            await fs.mkdir(outDir, { recursive: true });
            for (const name of await fs.readdir(outDir)) {
              if (/^price_guide_\d+_(?:[A-Z]{2}-\d{2}_exp-\d+|exp-\d+|exp-unknown)_\d{4}-\d{2}-\d{2}\.json$/.test(name) || name === 'index.json') {
                await fs.rm(path.join(outDir, name));
              }
            }

            const index = [];
            let totalUnmatched = 0;

            for (const { file, langOrMarket } of todaysGuides) {
              const src = await readJson(file);
              const { version, createdAt, priceGuides } = src || {};
              if (!Array.isArray(priceGuides)) continue;

              const groups = new Map(); const unknown = [];
              for (const e of priceGuides) {
                const p = productById.get(e.idProduct);
                if (p?.idExpansion != null) (groups.get(p.idExpansion) || groups.set(p.idExpansion, []).get(p.idExpansion)).push(e);
                else unknown.push(e);
              }

              for (const [expId, list] of groups.entries()) {
                list.sort((a,b)=>(a.idProduct??0)-(b.idProduct??0));
                const code = codeGuessForExpansion.get(expId) || null;
                const codePart = code ? `${code}_exp-${expId}` : `exp-${expId}`;
                const outName = `price_guide_${langOrMarket}_${codePart}_${targetDate}.json`;
                const outPath = path.join(outDir, outName);
                const outJson = { version, createdAt, idExpansion: expId, expansionCode: code, priceGuides: list };
                await fs.writeFile(outPath, stableStringify(outJson), 'utf8');
                index.push({ langOrMarket, idExpansion: expId, expansionCode: code, file: path.relative(ROOT, outPath), count: list.length });
                console.log(`✂️  ${path.relative(ROOT, file)} → ${path.relative(ROOT, outPath)} (${list.length})`);
              }

              totalUnmatched += unknown.length;
              if (unknown.length) {
                const outName = `price_guide_${langOrMarket}_exp-unknown_${targetDate}.json`;
                const outPath = path.join(outDir, outName);
                const outJson = { version, createdAt, idExpansion: null, expansionCode: null, priceGuides: unknown };
                await fs.writeFile(outPath, stableStringify(outJson), 'utf8');
                index.push({ langOrMarket, idExpansion: null, expansionCode: null, file: path.relative(ROOT, outPath), count: unknown.length });
                console.log(`⁉️  Unmatched: ${unknown.length} → ${path.relative(ROOT, outPath)}`);
              }
            }

            index.sort((a,b)=> (a.langOrMarket+b.file).localeCompare(b.langOrMarket+b.file));
            await fs.writeFile(path.join(outDir, 'index.json'), stableStringify({ date: targetDate, items: index, unmatched: totalUnmatched }), 'utf8');
            console.log(`\n✅ Split fertig. Zielordner: ${path.relative(ROOT, outDir)}`);
          }
          await main().catch(err => { console.error(err); process.exit(1); });
          EOF

      - name: Run splitter
        env:
          FORCE_DATE: ${{ inputs.date || '' }}
          MARKET_FILTER: ${{ inputs.market || '' }}
        run: node scripts/split-priceguide-by-expansion.mjs

      - name: Stage Final outputs (force, recursive)
        id: stage
        run: |
          echo "=== list final dir ==="
          ls -lahR "CM-Data/Final/PriceHistory" || true
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          # nur die Ausgabe-Ordner stagen (überschreibt .gitignore)
          git add -f -A -- CM-Data/Final/PriceHistory/
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true"  >> "$GITHUB_OUTPUT"
          fi
          echo "=== cached diff ==="
          git diff --cached --name-status | sed -n '1,200p'

      - name: Commit & direct push to main
        if: steps.stage.outputs.changed == 'true'
        run: |
          # Rebase, damit der Push fast-forward ist
          git fetch origin main
          git rebase origin/main || { echo "Rebase-Konflikt, Soft-Reset"; git reset --soft ORIG_HEAD; }
          git commit -m "chore(pricehistory): split by expansion [skip ci]"
          git push origin HEAD:main
